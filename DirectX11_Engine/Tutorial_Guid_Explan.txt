Tutorial 2
  - 기본
Tutorial 3
  - 배경색 / DirectX 초기화 / 카드 정보 출력
Totorial 4
- DirectX11의 정점(Vertex)과 픽셀 셰이더.
- 3D 그래픽스를 이해하고 응용하기 위해 필요한 가장 기본 개념
 *정점 버퍼(Vertex buffers)
  : 3D 공의 모형은 수백개의 삼각형으로 이루어진다.
    이 삼각형들은 세 꼭지점을 가지고 있는데, 이 꼭지점을 정점(vertex)라고 부른다.
	이 모든 정점들을 정점 버퍼(vertex buffer)라고 부르는 특별한 데이터 배열에 넣어주어야 한다.
 * 인덱스 버퍼(Index buffers)
  : 정점 버퍼에 있는 각 정점들이 연결되는 순서를 기록하기 위한 것. 
    GPU는 인덱스 버퍼를 이용해서 빠르게 정점 버퍼에서 필요한 몇몇 정점들을 찾아낸다.
	인덱스 버퍼의 사용이 비디오 메모리에서의 정점 데이터의 캐싱의 가능성을 높여준다.
 * 정점 셰이더(Vertex shaders)
  : 주로 정점 버퍼의 정점들을 3D공간으로 변환시켜주는 작은 프로그램.
   각 정점의 법선을 계산한다던가 하는 다른 연산도 가능하다.
    GPU에서 계산이 필요하다고 판단될 때 호출 된다.
	프로그램이 60fps의 fps를 가진 그래픽 프로그램에서는 단지 5000개의 삼각형을 그리기 위해 매초마다 900,000번의 정점 셰이더를 호출하게된다.
 * 픽셀 셰이더 (Pixel shaders)
  : 그리고자 하는 도형에 색상을 입힐 때를 위한 작은 프로그램
   화면에 보여지는 모든 픽셀들에 대해 GPU에서 연산된다.
    색상을 입히고(coloring), 텍스쳐를 입히고(texturing), 광원 효과를 주고(lighting), 그 외 다른 많은 도형 채색 효과를 주는 것이 바로 이 픽셀 셰이더 프로그램에서 제어 된다.
	GPU에 의해 수없이 호출 되기 때문에 반드시 효율적으로 작성되어야 한다.
 * HLSL(High Level Shader Language)
  : DirectX11에서 사용하는 작은 정점 및 픽셀 셰이더 프로그램을 작성할때 사용하는 언어.
  구문은 미리 정의된 타입이 있다는 것을 제외하면 C언와 거의 동일하다.
  전역 변수, 타입 정의, 정점 셰이더, 픽셀 셰이더, 기하 셰이더(geometry shader)로 구성되 있다.
   Color.vs / Color.ps
   : 셰이더는 실제 모델의 렌더링을 수행하는 작은 프로그램이다.

Tutorial 5
* 텍스쳐 다루기 ( Texture.vs / Texture.ps )
* 텍스쳐의 포맷은 .dds ( DirectX가 사용하는 Direct Draw Surface )
* dds 이미지의 픽셀들을 도형에 매핑시키기 위해 텍셀 좌표계(Texel coordinate system, Texture + Pixel)를 사용한다.
  이 체계 안에서 정수 값을 가진 픽셀 좌표는 0.0f와 1.0f 사이의 부동 소수점 좌표로 바뀌게 된다.
  너비가 256픽셀인 텍스쳐의 경우 첫번째 필섹을 x좌표가 0.0f이고, 256번째 픽셀은 1.0f좌표로 매핑되며, 중간에 위치한 128번째 픽셀은 0.5로 바뀐다.
* 텍셀 좌표계 
   가로성분(x축) : U : 가장 왼쪽이 0.0f -> 오른쪽 최 상단 1.0f
   세로성분(y축) : V : 왼쪽 최 상단이 0.0f -> 왼쪽 최 하단 1.0f

Tutorial 6
* 조명(Diffuse lighting)과 3D 객체 그리는 방법
* 방향 조명 (Directional lighting)
  태양이 지구를 비추는 것과 비슷한 개념. 태양은 엄청나게 먼 거리에서 빛을 비추는 광원이기 때문에 그 방향에 근거하여 물체에 얼마만큼의 빛이 투사되는지 어림잡을 수 있다.
  하지만 주변광(Ambient lighting)과는 달리 빛이 직접 닿지 않는 곳은 밝아지지 않는다.
  다른 조명 모델과는 달리 단순히 방향만 생각하면 되므로 계산에서의 요구사항이 단순하다.
  정점 셰이더와 픽셀 셰이더를 통해서 이루어진다.
  방향 조명이 도형을 비추기 위해서는 단지 방향 벡터와 법선 벡터만을 필요로 한다.
  방향벡터는 직접 지정하는 것이고, 법선 베거는 세 정점에 의해 만들어지는 평면으로 계산해 낼 수 있다.
  조명 방정식에 의한 색상도 구현한다.

Tutorial 7
* 3D 모델 렌더링
 HLSL을 이용하여 3D모델을 그리는 방법을 다룬다.
* 육면체(cube) 그리기
  모델의 포맷(구성)
  - 사용자들이 3D모델을 만들 수 있게 도와주는 툴 : 마야, 3D Studio Max
* 본인의 모델 포맷을 만들고 툴에서 만들어낸 포맷을 본인의 포맷으로 바꿔주는 파서를 만드는 것을 추천한다.
  사용하는 툴의 종류가 둘 이상이라면, 처리해야 할  포맷이 훨씬 많아진다.따라서 자신만의 포맷이 있고 툴들의 포맷을 본인의 포맷으로 바꾼다면 코드를 수정하지 않고, 파서 역할을 하는 프로그래만 수정하면 된다.
* 대부분의 3D 모델링 패키지들은 그 프로그램에게는 필요하겠지만 본인의 프로그램에는 전혀 필요 없는 수 많은 쓰레기 값을 담고 있다.
* 본인의 포맷을 만드는 것이 좋은 가장 큰 이유는 바로 여러분이 필요한 모든 값을 갖고 있고, 사용하기 쉽다는 것이다.
  애니메이션이나, 정적인것이나 그 외에 것들을 각기 저장하는 여러 포맷을 만드는 것을 생각 해 볼 수 있다.
* 기본 포맷 : 모델의 정점들을 연결하는 선, 각 선분들은 위치벡터(x,y,z)와 텍스쳐 좌표(tu, tv), 법선 벡터(nx, ny, nz)를 가지는 정점포맷과 일치한다.
  이 포맷은 가장 위에 정점의 개수가 있어서 첫번쨰 라인을 읽고 데이터를 읽기 위한 준비로 구조체들을 위한 메모리들을 미리 할당 할 수 있다.
  세 개의 선분이 삼각형을 만들며, 각 삼각형의 정점들은 시계 방향으로 배열되어 있어야 한다.
* Cube.txt 참조
  x,y,z,tu,tv,nx,ny,nz로 이루어진 36줄. 3줄마다 삼각형이 하나 만들어지므로 12개의 삼각형으로 이루어진 육면체를 볼수 있다.
* 어떤 툴이 어떤 좌표계를 쓰는지, 오른손 좌표계인지 왼손 좌표계인지를 알아야 한다.
  DirectX 11에서는 기본값으로 왼손 좌표계를 쓰므로 모델 데이터도 왼손 좌표계에 맞게 되어 있어야 한다. 그 차이를 계속 주시하고 파서 프로그램이 그런 좌표계를 올바르게 다루는지 확인해야 한다.
* 연습문제 해결 못함.

Tutorial 8
* 마야 2011 모델 불러오기
 - 마야2011(Maya 2011)에서 만든 3D모델을 불러오는 방법.
 - 3D_Obj_PassorEx 프로젝트
  연습문제 해결 못함.

Tutorial 9
* 주변광(Ambient lighting)
 햇빛이 직접 닿지 않는데도 빛이 비치는 것처럼 보이는 효과 ( 한번 더 반사되어 은은하게 비치는 빛 )
 - Moon.obj ( 구 깨짐 현상, UV 생성 후, 해결 완료. )

Tutorial 10
* 정반사광 (Specular lighting)
  - 밝은 점광원의 위치가 어디인지 알려주는 단서의 역할.
  - 거울이나 반짝반짝한 금속 표면과 같은 재질에서의 빛의 반사를 표현하는 거의 모든 경우에 사용된다.
  - 태양비칭 물에 반사되는 것과 같은 다른 재질도 이것으로 표현이 가능하다.
* 정반사광의 방정식
  참고 ( http://blog.naver.com/frogpjn?Redirect=Log&logNo=60015118840 )
  반사광 = 반사색 * ( 반사된 빛의 색 * ((법선과 하프벡터의 내적)^반사강도)*감쇄계수*스폿라이트계수)

  기본적인 정반사광 효과만을 위한 방정식
  반사과 = 반사빛의 색 * (보는방향과 반사광의 내적) ^ 반사강도
  => 이 식에서 반사광 벡터는 빛의 강도의 두배의 크기를 정점의 법선에 곱하고 여기에 빛의 방향을 빼서 얻어진다.

  반사벡터 = 2 * 빛의강도 * 법선 - 빛의 방향

  식에서 보는 방향은 카메라의 위치에서 정점의 위치를 뺌으로 계산 된다.

  보는 방향 = 카메라위치 - 정점위치


Tutorial 11
* 2D 렌더링
* 2D 화면 좌표계
  스크린 중앙(0,0) 왼쪽과 아래는 음수 좌표
* Z 버퍼 해제하기
  - 2D화면을 그리기 위해서는 Z버퍼를 사용하지 않아야 한다. 해당 픽셀에 올바른 새로운 색상을 덮어쓰기 위함.
    뒤쪽부터 그리기 시작해서 맨 앞을 나중에 그리는 화가 알고리즘(painter's algorithm)에 따라 원하는 결과물을 그릴 수 있다.
	2D화면을 다 그린 후, Z버퍼를 켜서 다시 3D객체를 그릴 수 있따.
	Z버퍼를 켜고 끄기 위해선 스텐실의 DepthEnable 변수가 false인 두번째 스탠실 상태를 만들어 바꿔 사용한다.
* 동적 정점 버퍼(Dynamic vertex buffer)
 - 지금까지는 정적 정점 버퍼 사용했음.
 - 정적 정점 버퍼의 문제점은 버퍼 내부의 값을 바꿀 수 없다는 것.
   동적 정점 버퍼는 필요하다면 매 프레임마다 정점 버퍼의 내용을 바꿀 수 있게 해준다.
   속도는 느리지만, 이전에는 할 수 없었던 추가 기능이 지원된다.
 - 2D 렌더링에서 동적 정점 버퍼를 사용하는 이유는 종종 이미지를 화면 내 다양한 위치로 옮겨야 하는 경우가 있기 때문이다.
   ( 마우스 포인터 등 )
 # 동적 정점 버퍼는 정적인 것보다 속도가 뒤쳐지기 때문에 필요한 경우에만 사용해야 한다.
   매 프레임마다 정적 정점 버퍼를 없애고 다시 생성하는 것은 지양 해야 한다. : 그래픽 카드를 거의 완전히 잠그는 효과 발생( ATI그래픽 카드의 경우 ) 동적 정점 버프를 쓰는 것보다 성능이 떨어진다.
* 정사영(Orthographic projection)
 - 일반 3D 투영 행렬이 아닌 정사영 행렬을 사용하는 것.
 

 Tutorial 12
* 글꼴 엔진
* 자신만의 글꼴 이미지를 만들어서 사용 가능하다.
  하나의 텍스쳐 파일 안에 필요한 기본 글자가 모두 들어 있어야 한다.
  필요한 글자의 텍스쳐를 인덱스를 이용해 그려내는 단순한 글꼴 엔진을 만들 수 있다.
  2개의 삼각형으로 이루어진 사각형을 만들고 그 사각형에 원하는 글자의 텍스쳐를 그리면 된다.
  문장이 있으면 문장에 있는 각 문자별로 사각형을 만들어 주고 그 위에 글자를 그린다.
  모든 사각형이 화면에 그려지면 문장이 완성된다. (2D 이미지를 화면에 그리는 형태)
* 텍스쳐에 인덱스를 먹일 때 필요한 것은 각 글자가 실제로 텍스쳐의 어느 부분에 있는가 하는 정보가 담긴 텍스트 파일 이다.
  이 텍스트 파일은 글꼴 엔진에게 재빨리 그릴 수 있는 픽셀 위치를 잡아준다. 
* 텍스쳐 인덱스 파일의 포맷
  [글자의 아스키코드][글자][왼쪽U좌표][오른쪽U좌표][글자의픽셀너비]
* font.dds / fontdata.txt
  인덱스파일과 텍스쳐파일이 있으면 글꼴 엔진을 만들 수있다.
  자신만의 인덱스 파일을 만들고 싶다면, 각 글자가 공백으로 분리되도록 해야 하고, 빈공간이 없다면 스스로 TU, TV좌표를 만드는 비트맵 파서를 작성할 수 있어야 한다.
   ( 비트맵 폰으를 쉽게 만들 수 있도록 해주는 BMFont라는 툴이 있다)
* 해상도 크기에 따라서 이미지 그리기가 달라 질 수 있으므로, 여러가지 해상도에 적용할 수 있는 폰트 정보가 필요하다.

Tutorial 13
* DirectInput
  DirectX API가 제공하는 고속의 입력 함수의 모음. 일반적인 윈도우의 입력 시스템에 비해 믿을 수 없을 정도로 빠르다.
  입력에 대한 빠른 응답 시간을 요구하는 어플리케이션이라면 DirectInput을 사용해야 한다.
* 키보드와 마우스 장치에 대한 Direct Input의 구현

Tutorial 14
* DirectSound
  - 윈도운 보안체계에 따라, 하드웨어 레벨의 사운드 믹싱이 되지 않는다.
  - Directsound API는 DirectX8과 같다.
  - 원하는 어떤 종류의 오디오 포맷이든지 잘 지원한다.
* 알아둘 것
 - 1차 버퍼와 2차 버퍼로 두 버퍼를 나누어 사용한다.
 - 1차 버퍼는 사운드 카드나 USB 헤드셋과 같은 것에 있는 메인 사운드 버퍼 이다.
 - 2차 버퍼는 실제로 어플리케이션에서 생성하고 그곳에 소리가 로드되는 메모리 영역이다.
 - 2차 버퍼의 소리를 재생할 떄 Direct sound API에서는 이들을 1차 버퍼의 소리들과 잘 혼합하여 재생하게 된다.
 - 여러개의 2차 버퍼들을 동시에 재생한다면 전부 혼합되어 1차 버퍼에서 재생된다.
 - 이 퍼버들은 앞뒤가 이어져 있기 때문에(circular) 무한히 반복 재생되게 할 수 있다.
 ** WaveSoundPlayer (MFC wavePlayer)

Tutorial 15
 * FPS, CPU 사용량, 타이머
 * fps 카운터와 cpu 사용량 측정, 고해상도 시간 측정 기능 캡슐화.

Tutorial 16
* 프러스텀 컬링 
* 화면에 그려지는 3차원 영역의 보이는 부분을 시야 프러스텀(viewing frustum, 시야 절두체)
   : 프로스텀 안에 있는 모든 것은 비디오카드에 그려진다.
     프로스텀 바깥에 있는 것은 렌더링 과정에서 판단하고 그리지 않는다.
* 큰 화면을 가진 경우 비디오 카드에 의존한 채 컬링을 하는 것은 많은 연산을 요구할 수 있다.
   렌더링 직전에 모델들이 프러스텀 내부에 있는지 아닌지 확인하는 일을 해준다.
   이를 통해 모든 삼각형들을 비디오 카드로 보내는 것이 아니라 정확히 그려야 할 것만 카드로 보낼 수 있게 된다.
   이것이 처리되는 방식은 각각의 모델들을 정육면체나 그냥 육면체 또는 구체로 감싸고 이 물체가 보이는지는 정육면체나 상자, 구체가 보이는지의 여부로 판단하는 것이다.
   이를 위해 필요한 수학은 단지 몇줄뿐이지만 수천개의 삼각형들의 테스트 연산들을 절약해 준다.
* 랜덤으로 생성된 25개의 구체들이 있는 장면을 생성
  카메라를 왼쪽/오른쪽 버튼으로 돌리면서 시야 바깥에 있는 구체들이 컬렁되는지 테스트.
  보이는 구체의 개수와 보이지 않는 구체들의 개수를 화면에 표시.


Tutorial 17
* Multitexturing / Texture Array
 텍스쳐 배열을 사용하는 방법과 더불어 멀티텍스쳐(Multitexturing, 다중 텍스쳐)를 사용하는 방법을 다룬다.
 멀티텍스쳐링은 두 개의 서로 다른 텍스쳐를 혼합하여 하나의 텍스쳐로 만드는 과정이다.
 두 텍스쳐를 혼합하는 공식은 원하는 바에 따라 다르게 설계 할 수 있다.
  : 두 텍스쳐의 픽셀값의 평균으로 값을 내어 골고루 혼합된 최종 텍스쳐 얻기
    blendColor = basePixel * colorPixel * gammaCorrection
	이미지 픽셀들이 이미 모니터의 감마값에 맞추어져 있기 때문에, 감마값이 픽셀값들을 0.0에서 0.1사이의 곡선 형태로 나타나게 한다. 
	비선형적인 색상값들을 다루기 위햇 감마 보정이라는 단계가 필요하다. 감마 보정을 하지 않고 단순히 반반 더해버리면 원하는 이미지를 얻을 수 없다.

* 텍스쳐 배열은 여러 텍스쳐들을 동시에 gpu에서 활용하는 기능 (DirectX10에서 소개 됨)
  그 이전에는 gpu에서 한 번에 하나의 텍스쳐만 사용할 수 있었기 때문에 텍스쳐를 로드하고 해제하는 과정에서 많은 오버헤드가 발생했다. 
  이 문제를 텍스쳐 아틀라스( Texture atlas, 여러 작은 텍스쳐들을 하나의 큰 텍스처에 모아 놓은 것)를 만들어 놓고 단지 uv값만 바꾸어 이용하는 방식으로 해결했다.
  하지만 멀티텍스쳐링을 사용하면 텍스쳐 아틀라스는 더 이상 필요하지 않는다.

* 감마값은 장치마다 다르다.


Tutorial 18
* Light Map
 보조 텍스쳐나 데이터 파일을 일종의 참조 테이블로 이용하여 아주 약간의 연산만을 수행하여 독특한 광원 효과를 만들 수 있는 방법이다.
 : 보조 텍스쳐를 광원효과의 기초로 삼고 다른 광원 효과 관련된 계산은 하지 않는다. 이는 속도가 효율적이다.

* 첫번째 텍스쳐는 기본 텍스쳐, 두번쨰 텍스쳐는 라이트맵 (검정과 하얀색만으로 각 픽셀의 음영을 낸 것.


Tutorial 19
* 알파 매핑 (Alpha mapping)
 두 텍스쳐를 혼합 할 때, 알파 레이어를 이용하여 각 픽셀이 어느 정도 혼합되어야 하는지를 계산하는 과정.

Tutorial 20
* 범프 매핑 (Bump Mapping)
 범프 매핑을 하기 위해서는 노멀 맵(Normal Map)이라는 특별한 텍스쳐를 사용하여 노멀 매핑(Normal mapping)이라고도 한다.
 노멀 맵은 표면의 법선(Normal)을 구하기 위한 참조 테이블로 사용 된다.
 ( 범프 매핑에는 노멀 매핑 이외에도 여러 방법이 있지만, 여기서는 가장 간단하고 자주 사용되는 노멀 매핑을 다룬다.)

* 노멀 맵을 만들어주는 툴은 x,y,z좌표를 가지고 해당 픽셀의 r,g,b 값으로 넣게 되는데, 각 색상은 해당 픽셀에 있게 될 법선의 각도를 표현한다.
도형의 법선은 여전히 이전과 같이 계산되지만 다른 두 종류의 법선을 계산하기 위해서는 정점과 텍스쳐 좌표의 정보가 필요하다. 
다른 두 법선은 각각 탄젠트 법선(tangent)과 종법선(binormal)이라 한다. 
( 이 범프 매핑은 탄젠트 공간상의 법선을 노멀 맵에 저장한다. 탄젠트 공간에 대한 설명이 필요한데 간단히 말하자면 탄젠트 공간은 normal이 항상 z축이 되는 공간이다.
 나머지 tangent축과 binormal축은 언제나 normal과 수직이며, tangent와 binormal끼리는 수직일 필요는 없다. 결국 tnagent와 binormal은 같은 평면위에 존재하는 축이다.)

법선은 언제나 보는 사람을 향해 뻗어 나간다. tangent와 binormal은 폴리곤 평면과 평행한데 tangent는 x축 binormal은 y축 방향으로 표현된다.
이 두 법선은 노멀 맵 텍스쳐의 uv좌표계에 바로 대응되는데, u좌표가 tangent, v좌표가 binormal이 된다.

binormal과 tangent벡터를 구하기 위해서는 폴리곤의 법선과 텍스쳐 좌표를 이용한 몇 가지 계산을 미리 해야 한다.
하지만 이 연산은 부동소수점 연산이 많아 비용이 많이 들기 때문에 셰이더에서 하면 안된다. 대신에 c++코드에서 모델을 불러올때 이 연산을 진행한다.
범프 맵 효과를 많은 폴리곤으로 이루어진 모델에 적용하려고 할 때에도 서로 다른 법선들을 미리 계산해서 저장 해 두는 것이 좋다.

다음 공식과 노멀 맵을 이용하여 변환된 법선을 구한다.
bumpNormal = normal + bumpMap.x * tangent + bumpMap.y * binormal;

해당 픽셀의 노멀을 구했다면 빛의 방향과 계산하고 텍스쳐 색상을 곱해 최종결과를 도출 할 수 있다.


Tutorial 21
* 반사 매핑 (specular mapping)
  : 반사 매핑을 구현하고 어떻게 범프 매핑과 같이 사용할 수 있는가.
* 텍스쳐의 픽셀마다 알파값을 해당 픽셀에서의 빛의 세기로 활용하는 참조 테이블로서 사용한다.
  참조 방법은 라이트 맵과 같지만 이번에는 그 값을 정반사광으로 강조하는 데 사용한다.