Tutorial 2
  - 기본
Tutorial 3
  - 배경색 / DirectX 초기화 / 카드 정보 출력
Totorial 4
- DirectX11의 정점(Vertex)과 픽셀 셰이더.
- 3D 그래픽스를 이해하고 응용하기 위해 필요한 가장 기본 개념
 *정점 버퍼(Vertex buffers)
  : 3D 공의 모형은 수백개의 삼각형으로 이루어진다.
    이 삼각형들은 세 꼭지점을 가지고 있는데, 이 꼭지점을 정점(vertex)라고 부른다.
	이 모든 정점들을 정점 버퍼(vertex buffer)라고 부르는 특별한 데이터 배열에 넣어주어야 한다.
 * 인덱스 버퍼(Index buffers)
  : 정점 버퍼에 있는 각 정점들이 연결되는 순서를 기록하기 위한 것. 
    GPU는 인덱스 버퍼를 이용해서 빠르게 정점 버퍼에서 필요한 몇몇 정점들을 찾아낸다.
	인덱스 버퍼의 사용이 비디오 메모리에서의 정점 데이터의 캐싱의 가능성을 높여준다.
 * 정점 셰이더(Vertex shaders)
  : 주로 정점 버퍼의 정점들을 3D공간으로 변환시켜주는 작은 프로그램.
   각 정점의 법선을 계산한다던가 하는 다른 연산도 가능하다.
    GPU에서 계산이 필요하다고 판단될 때 호출 된다.
	프로그램이 60fps의 fps를 가진 그래픽 프로그램에서는 단지 5000개의 삼각형을 그리기 위해 매초마다 900,000번의 정점 셰이더를 호출하게된다.
 * 픽셀 셰이더 (Pixel shaders)
  : 그리고자 하는 도형에 색상을 입힐 때를 위한 작은 프로그램
   화면에 보여지는 모든 픽셀들에 대해 GPU에서 연산된다.
    색상을 입히고(coloring), 텍스쳐를 입히고(texturing), 광원 효과를 주고(lighting), 그 외 다른 많은 도형 채색 효과를 주는 것이 바로 이 픽셀 셰이더 프로그램에서 제어 된다.
	GPU에 의해 수없이 호출 되기 때문에 반드시 효율적으로 작성되어야 한다.
 * HLSL(High Level Shader Language)
  : DirectX11에서 사용하는 작은 정점 및 픽셀 셰이더 프로그램을 작성할때 사용하는 언어.
  구문은 미리 정의된 타입이 있다는 것을 제외하면 C언와 거의 동일하다.
  전역 변수, 타입 정의, 정점 셰이더, 픽셀 셰이더, 기하 셰이더(geometry shader)로 구성되 있다.
   Color.vs / Color.ps
   : 셰이더는 실제 모델의 렌더링을 수행하는 작은 프로그램이다.

Tutorial 5
* 텍스쳐 다루기 ( Texture.vs / Texture.ps )
* 텍스쳐의 포맷은 .dds ( DirectX가 사용하는 Direct Draw Surface )
* dds 이미지의 픽셀들을 도형에 매핑시키기 위해 텍셀 좌표계(Texel coordinate system, Texture + Pixel)를 사용한다.
  이 체계 안에서 정수 값을 가진 픽셀 좌표는 0.0f와 1.0f 사이의 부동 소수점 좌표로 바뀌게 된다.
  너비가 256픽셀인 텍스쳐의 경우 첫번째 필섹을 x좌표가 0.0f이고, 256번째 픽셀은 1.0f좌표로 매핑되며, 중간에 위치한 128번째 픽셀은 0.5로 바뀐다.
* 텍셀 좌표계 
   가로성분(x축) : U : 가장 왼쪽이 0.0f -> 오른쪽 최 상단 1.0f
   세로성분(y축) : V : 왼쪽 최 상단이 0.0f -> 왼쪽 최 하단 1.0f

Tutorial 6
* 조명(Diffuse lighting)과 3D 객체 그리는 방법
* 방향 조명 (Directional lighting)
  태양이 지구를 비추는 것과 비슷한 개념. 태양은 엄청나게 먼 거리에서 빛을 비추는 광원이기 때문에 그 방향에 근거하여 물체에 얼마만큼의 빛이 투사되는지 어림잡을 수 있다.
  하지만 주변광(Ambient lighting)과는 달리 빛이 직접 닿지 않는 곳은 밝아지지 않는다.
  다른 조명 모델과는 달리 단순히 방향만 생각하면 되므로 계산에서의 요구사항이 단순하다.
  정점 셰이더와 픽셀 셰이더를 통해서 이루어진다.
  방향 조명이 도형을 비추기 위해서는 단지 방향 벡터와 법선 벡터만을 필요로 한다.
  방향벡터는 직접 지정하는 것이고, 법선 베거는 세 정점에 의해 만들어지는 평면으로 계산해 낼 수 있다.
  조명 방정식에 의한 색상도 구현한다.

Tutorial 7
* 3D 모델 렌더링
 HLSL을 이용하여 3D모델을 그리는 방법을 다룬다.
* 육면체(cube) 그리기
  모델의 포맷(구성)
  - 사용자들이 3D모델을 만들 수 있게 도와주는 툴 : 마야, 3D Studio Max
* 본인의 모델 포맷을 만들고 툴에서 만들어낸 포맷을 본인의 포맷으로 바꿔주는 파서를 만드는 것을 추천한다.
  사용하는 툴의 종류가 둘 이상이라면, 처리해야 할  포맷이 훨씬 많아진다.따라서 자신만의 포맷이 있고 툴들의 포맷을 본인의 포맷으로 바꾼다면 코드를 수정하지 않고, 파서 역할을 하는 프로그래만 수정하면 된다.
* 대부분의 3D 모델링 패키지들은 그 프로그램에게는 필요하겠지만 본인의 프로그램에는 전혀 필요 없는 수 많은 쓰레기 값을 담고 있다.
* 본인의 포맷을 만드는 것이 좋은 가장 큰 이유는 바로 여러분이 필요한 모든 값을 갖고 있고, 사용하기 쉽다는 것이다.
  애니메이션이나, 정적인것이나 그 외에 것들을 각기 저장하는 여러 포맷을 만드는 것을 생각 해 볼 수 있다.
* 기본 포맷 : 모델의 정점들을 연결하는 선, 각 선분들은 위치벡터(x,y,z)와 텍스쳐 좌표(tu, tv), 법선 벡터(nx, ny, nz)를 가지는 정점포맷과 일치한다.
  이 포맷은 가장 위에 정점의 개수가 있어서 첫번쨰 라인을 읽고 데이터를 읽기 위한 준비로 구조체들을 위한 메모리들을 미리 할당 할 수 있다.
  세 개의 선분이 삼각형을 만들며, 각 삼각형의 정점들은 시계 방향으로 배열되어 있어야 한다.
* Cube.txt 참조
  x,y,z,tu,tv,nx,ny,nz로 이루어진 36줄. 3줄마다 삼각형이 하나 만들어지므로 12개의 삼각형으로 이루어진 육면체를 볼수 있다.
* 어떤 툴이 어떤 좌표계를 쓰는지, 오른손 좌표계인지 왼손 좌표계인지를 알아야 한다.
  DirectX 11에서는 기본값으로 왼손 좌표계를 쓰므로 모델 데이터도 왼손 좌표계에 맞게 되어 있어야 한다. 그 차이를 계속 주시하고 파서 프로그램이 그런 좌표계를 올바르게 다루는지 확인해야 한다.
* 연습문제 해결 못함.

Tutorial 8
* 마야 2011 모델 불러오기
 - 마야2011(Maya 2011)에서 만든 3D모델을 불러오는 방법.
 - 3D_Obj_PassorEx 프로젝트
  연습문제 해결 못함.

Tutorial 9
* 주변광(Ambient lighting)
 햇빛이 직접 닿지 않는데도 빛이 비치는 것처럼 보이는 효과 ( 한번 더 반사되어 은은하게 비치는 빛 )
 - Moon.obj ( 구 깨짐 현상, UV 생성 후, 해결 완료. )

Tutorial 10
* 정반사광 (Specular lighting)
  - 밝은 점광원의 위치가 어디인지 알려주는 단서의 역할.
  - 거울이나 반짝반짝한 금속 표면과 같은 재질에서의 빛의 반사를 표현하는 거의 모든 경우에 사용된다.
  - 태양비칭 물에 반사되는 것과 같은 다른 재질도 이것으로 표현이 가능하다.
* 정반사광의 방정식
  참고 ( http://blog.naver.com/frogpjn?Redirect=Log&logNo=60015118840 )
  반사광 = 반사색 * ( 반사된 빛의 색 * ((법선과 하프벡터의 내적)^반사강도)*감쇄계수*스폿라이트계수)

  기본적인 정반사광 효과만을 위한 방정식
  반사과 = 반사빛의 색 * (보는방향과 반사광의 내적) ^ 반사강도
  => 이 식에서 반사광 벡터는 빛의 강도의 두배의 크기를 정점의 법선에 곱하고 여기에 빛의 방향을 빼서 얻어진다.

  반사벡터 = 2 * 빛의강도 * 법선 - 빛의 방향

  식에서 보는 방향은 카메라의 위치에서 정점의 위치를 뺌으로 계산 된다.

  보는 방향 = 카메라위치 - 정점위치


Tutorial 11
* 2D 렌더링
* 2D 화면 좌표계
  스크린 중앙(0,0) 왼쪽과 아래는 음수 좌표
* Z 버퍼 해제하기
  - 2D화면을 그리기 위해서는 Z버퍼를 사용하지 않아야 한다. 해당 픽셀에 올바른 새로운 색상을 덮어쓰기 위함.
    뒤쪽부터 그리기 시작해서 맨 앞을 나중에 그리는 화가 알고리즘(painter's algorithm)에 따라 원하는 결과물을 그릴 수 있다.
	2D화면을 다 그린 후, Z버퍼를 켜서 다시 3D객체를 그릴 수 있따.
	Z버퍼를 켜고 끄기 위해선 스텐실의 DepthEnable 변수가 false인 두번째 스탠실 상태를 만들어 바꿔 사용한다.
* 동적 정점 버퍼(Dynamic vertex buffer)
 - 지금까지는 정적 정점 버퍼 사용했음.
 - 정적 정점 버퍼의 문제점은 버퍼 내부의 값을 바꿀 수 없다는 것.
   동적 정점 버퍼는 필요하다면 매 프레임마다 정점 버퍼의 내용을 바꿀 수 있게 해준다.
   속도는 느리지만, 이전에는 할 수 없었던 추가 기능이 지원된다.
 - 2D 렌더링에서 동적 정점 버퍼를 사용하는 이유는 종종 이미지를 화면 내 다양한 위치로 옮겨야 하는 경우가 있기 때문이다.
   ( 마우스 포인터 등 )
 # 동적 정점 버퍼는 정적인 것보다 속도가 뒤쳐지기 때문에 필요한 경우에만 사용해야 한다.
   매 프레임마다 정적 정점 버퍼를 없애고 다시 생성하는 것은 지양 해야 한다. : 그래픽 카드를 거의 완전히 잠그는 효과 발생( ATI그래픽 카드의 경우 ) 동적 정점 버프를 쓰는 것보다 성능이 떨어진다.
* 정사영(Orthographic projection)
 - 일반 3D 투영 행렬이 아닌 정사영 행렬을 사용하는 것.
 

 Tutorial 12
* 글꼴 엔진
* 자신만의 글꼴 이미지를 만들어서 사용 가능하다.
  하나의 텍스쳐 파일 안에 필요한 기본 글자가 모두 들어 있어야 한다.
  필요한 글자의 텍스쳐를 인덱스를 이용해 그려내는 단순한 글꼴 엔진을 만들 수 있다.
  2개의 삼각형으로 이루어진 사각형을 만들고 그 사각형에 원하는 글자의 텍스쳐를 그리면 된다.
  문장이 있으면 문장에 있는 각 문자별로 사각형을 만들어 주고 그 위에 글자를 그린다.
  모든 사각형이 화면에 그려지면 문장이 완성된다. (2D 이미지를 화면에 그리는 형태)
* 텍스쳐에 인덱스를 먹일 때 필요한 것은 각 글자가 실제로 텍스쳐의 어느 부분에 있는가 하는 정보가 담긴 텍스트 파일 이다.
  이 텍스트 파일은 글꼴 엔진에게 재빨리 그릴 수 있는 픽셀 위치를 잡아준다. 
* 텍스쳐 인덱스 파일의 포맷
  [글자의 아스키코드][글자][왼쪽U좌표][오른쪽U좌표][글자의픽셀너비]
* font.dds / fontdata.txt
  인덱스파일과 텍스쳐파일이 있으면 글꼴 엔진을 만들 수있다.
  자신만의 인덱스 파일을 만들고 싶다면, 각 글자가 공백으로 분리되도록 해야 하고, 빈공간이 없다면 스스로 TU, TV좌표를 만드는 비트맵 파서를 작성할 수 있어야 한다.
   ( 비트맵 폰으를 쉽게 만들 수 있도록 해주는 BMFont라는 툴이 있다)
* 해상도 크기에 따라서 이미지 그리기가 달라 질 수 있으므로, 여러가지 해상도에 적용할 수 있는 폰트 정보가 필요하다.

Tutorial 13
* DirectInput
  DirectX API가 제공하는 고속의 입력 함수의 모음. 일반적인 윈도우의 입력 시스템에 비해 믿을 수 없을 정도로 빠르다.
  입력에 대한 빠른 응답 시간을 요구하는 어플리케이션이라면 DirectInput을 사용해야 한다.
* 키보드와 마우스 장치에 대한 Direct Input의 구현